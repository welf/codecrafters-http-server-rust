{"files":[{"path":["/","Users","aw","Dev","Rust","codecrafters-http-server-rust","src","handlers.rs"],"content":"use tokio::{\n    io::{AsyncBufReadExt, AsyncWriteExt, BufReader},\n    net::TcpStream,\n};\n\nuse crate::http::{ParseRequestError, Request, Response, ResponseBuilder};\n\npub async fn handle_connection(\n    mut stream: TcpStream,\n    files_dir: &String,\n) -> Result<(), ParseRequestError> {\n    let mut buf_reader = BufReader::new(&mut stream);\n\n    let request_str = std::str::from_utf8(buf_reader.fill_buf().await?)?;\n\n    let request = Request::try_from(request_str)?;\n\n    let path = request.uri.as_str();\n\n    let response = match path {\n        \"/\" => ResponseBuilder::ok()\n            .with(vec![\n                (\"Connection\", \"Keep-Alive\"),\n                (\"Keep-Alive\", \"timeout=5, max=1000\"),\n            ])\n            // Disable Content-Length header generation to pass codecrafters tests\n            .without_content_length_header()\n            .build(),\n\n        \"/user-agent\" => get_user_agent_response(&request),\n\n        other => {\n            if other.starts_with(\"/echo/\") {\n                get_echo_response(other.trim_start_matches(\"/echo/\"))\n            } else if path.starts_with(\"/files/\") {\n                get_file_response(other.trim_start_matches(\"/files/\"), files_dir)\n            } else {\n                ResponseBuilder::not_found().build()\n            }\n        }\n    };\n\n    stream\n        .write_all(response.to_bytes_vec().as_slice())\n        .await\n        .expect(\"Failed to write to stream\");\n\n    stream.flush().await.expect(\"Failed to flush stream\");\n\n    Ok(())\n}\n\nfn get_file_response(file_name: &str, files_dir: &String) -> Response {\n    let path = format!(\"{}/{}\", files_dir, file_name);\n    let file = match std::fs::read(path) {\n        Ok(file) => file,\n        Err(_) => {\n            return ResponseBuilder::not_found()\n                .without_content_length_header()\n                .build()\n        }\n    };\n\n    ResponseBuilder::ok()\n        .with((\"Content-Type\", \"application/octet-stream\"))\n        .body(file)\n        .build()\n}\n\nfn get_user_agent_response(request: &Request) -> Response {\n    let user_agent = request\n        .headers\n        .iter()\n        .find(|(k, _)| k == \"User-Agent\")\n        .map(|(_, v)| v);\n\n    match user_agent {\n        Some(user_agent) => ResponseBuilder::ok()\n            .with((\"Content-Type\", \"text/plain\"))\n            .body(user_agent.as_bytes().to_vec())\n            .build(),\n        None => ResponseBuilder::bad_request().build(),\n    }\n}\n\nfn get_echo_response(content: &str) -> Response {\n    let response_builder = ResponseBuilder::ok().with((\"Content-Type\", \"text/plain\"));\n\n    if content.is_empty() {\n        response_builder.build()\n    } else {\n        response_builder.body(content).build()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::http::{Request, StatusCode};\n    use std::fs::OpenOptions;\n\n    #[test]\n    fn test_get_user_agent_response() {\n        let request =\n            Request::try_from(\"GET /user-agent HTTP/1.1\\r\\nUser-Agent: curl/7.68.0\\r\\n\\r\\n\")\n                .unwrap();\n\n        let response = get_user_agent_response(&request);\n\n        let body_len_str = \"curl/7.68.0\".len().to_string();\n        let headers: Vec<(String, String)> = vec![\n            (\"Content-Type\".to_string(), \"text/plain\".to_string()),\n            (\"Content-Length\".to_string(), body_len_str),\n        ];\n\n        assert_eq!(response.status_code, StatusCode::Ok);\n        assert_eq!(response.headers, headers);\n        assert_eq!(response.body, Some(b\"curl/7.68.0\".to_vec()));\n    }\n\n    #[test]\n    fn test_get_user_agent_response_no_user_agent() {\n        let request = Request::try_from(\"GET /user-agent HTTP/1.1\\r\\n\\r\\n\").unwrap();\n\n        let response = get_user_agent_response(&request);\n\n        assert_eq!(response.status_code, StatusCode::BadRequest);\n        assert_eq!(\n            response.headers,\n            vec![(\"Content-Length\".to_string(), \"0\".to_string())]\n        );\n        assert_eq!(response.body, None);\n    }\n\n    #[test]\n    fn test_get_echo_response() {\n        let request = Request::try_from(\"GET /echo/Hello%20World HTTP/1.1\\r\\n\\r\\n\").unwrap();\n\n        let path = request.uri.as_str().trim_start_matches(\"/echo/\");\n\n        let response = get_echo_response(path);\n\n        let body_len_str = b\"Hello%20World\".len().to_string();\n        let headers: Vec<(String, String)> = vec![\n            (\"Content-Type\".to_string(), \"text/plain\".to_string()),\n            (\"Content-Length\".to_string(), body_len_str),\n        ];\n\n        assert_eq!(response.status_code, StatusCode::Ok);\n        assert_eq!(response.headers, headers);\n        assert_eq!(response.body, Some(b\"Hello%20World\".to_vec()));\n\n        let request = Request::try_from(\"GET /echo/ HTTP/1.1\\r\\n\\r\\n\").unwrap();\n\n        let path = request.uri.as_str().trim_start_matches(\"/echo/\");\n\n        let response = get_echo_response(path);\n        let headers: Vec<(String, String)> = vec![\n            (\"Content-Type\".to_string(), \"text/plain\".to_string()),\n            (\"Content-Length\".to_string(), \"0\".to_string()),\n        ];\n\n        assert_eq!(response.status_code, StatusCode::Ok);\n        assert_eq!(response.headers, headers);\n        assert_eq!(response.body, None);\n    }\n\n    #[test]\n    fn test_get_file_response() {\n        let root_dir = env!(\"CARGO_MANIFEST_DIR\");\n        let tmp_dir = format!(\"{}/tmp\", root_dir);\n        let files_dir = format!(\"{}/files\", tmp_dir);\n        let file_name = \"test.txt\";\n        let file_content = \"Hello World\";\n\n        // Create files directory if it doesn't exist\n        std::fs::create_dir_all(&files_dir).unwrap();\n\n        // Create temporary file\n        let file_path = format!(\"{}/{}\", files_dir, file_name);\n        dbg!(&file_path);\n        OpenOptions::new()\n            .write(true)\n            .create(true)\n            .truncate(true)\n            .open(&file_path)\n            .unwrap();\n\n        std::fs::write(file_path, file_content).unwrap();\n\n        let response = get_file_response(file_name, &files_dir);\n\n        assert_eq!(response.status_code, StatusCode::Ok);\n        assert_eq!(\n            response.headers,\n            vec![\n                (\n                    \"Content-Type\".to_string(),\n                    \"application/octet-stream\".to_string()\n                ),\n                (\"Content-Length\".to_string(), file_content.len().to_string())\n            ]\n        );\n        assert_eq!(response.body, Some(file_content.as_bytes().to_vec()));\n\n        // Remove temporary directory and its contents\n        std::fs::remove_dir_all(tmp_dir).unwrap();\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":18,"coverable":40},{"path":["/","Users","aw","Dev","Rust","codecrafters-http-server-rust","src","http","error.rs"],"content":"use std::{fmt::Display, str::Utf8Error};\n\nuse super::method::MethodError;\n\n#[derive(Debug)]\npub struct ParseRequestError {\n    pub kind: ParseRequestErrorKind,\n}\n\n#[derive(Debug, PartialEq)]\npub enum ParseRequestErrorKind {\n    EncodingError,\n    InvalidMethod,\n    InvalidProtocol,\n    InvalidRequest,\n    NetworkError,\n}\n\nimpl ParseRequestError {\n    pub const fn message(&self) -> &'static str {\n        match self.kind {\n            ParseRequestErrorKind::InvalidRequest => \"Invalid Request\",\n            ParseRequestErrorKind::EncodingError => \"Invalid Request Encoding\",\n            ParseRequestErrorKind::InvalidMethod => \"Invalid Request Method\",\n            ParseRequestErrorKind::InvalidProtocol => \"Invalid Request Protocol\",\n            ParseRequestErrorKind::NetworkError => \"Network I/O Error\",\n        }\n    }\n}\n\nimpl From<Utf8Error> for ParseRequestError {\n    fn from(_: Utf8Error) -> Self {\n        Self {\n            kind: ParseRequestErrorKind::EncodingError,\n        }\n    }\n}\n\nimpl From<MethodError> for ParseRequestError {\n    fn from(_: MethodError) -> Self {\n        Self {\n            kind: ParseRequestErrorKind::InvalidMethod,\n        }\n    }\n}\n\nimpl From<std::io::Error> for ParseRequestError {\n    fn from(_: std::io::Error) -> Self {\n        Self {\n            kind: ParseRequestErrorKind::NetworkError,\n        }\n    }\n}\n\nimpl Display for ParseRequestError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"Request parsing error: {}\", self.message())\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":12},{"path":["/","Users","aw","Dev","Rust","codecrafters-http-server-rust","src","http","method.rs"],"content":"use std::{\n    fmt::{self, Display, Formatter},\n    str::FromStr,\n};\n\n#[derive(Debug, PartialEq, Clone, Copy)]\npub enum Method {\n    Get,\n    Post,\n    Put,\n    Delete,\n    Patch,\n    Options,\n    Head,\n    Connect,\n    Trace,\n}\n\nimpl FromStr for Method {\n    type Err = MethodError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"GET\" => Ok(Self::Get),\n            \"POST\" => Ok(Self::Post),\n            \"PUT\" => Ok(Self::Put),\n            \"DELETE\" => Ok(Self::Delete),\n            \"PATCH\" => Ok(Self::Patch),\n            \"OPTIONS\" => Ok(Self::Options),\n            \"HEAD\" => Ok(Self::Head),\n            \"CONNECT\" => Ok(Self::Connect),\n            \"TRACE\" => Ok(Self::Trace),\n            _ => Err(MethodError),\n        }\n    }\n}\n\nimpl Display for Method {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        let method = match self {\n            Self::Get => \"GET\",\n            Self::Post => \"POST\",\n            Self::Put => \"PUT\",\n            Self::Delete => \"DELETE\",\n            Self::Patch => \"PATCH\",\n            Self::Options => \"OPTIONS\",\n            Self::Head => \"HEAD\",\n            Self::Connect => \"CONNECT\",\n            Self::Trace => \"TRACE\",\n        };\n        write!(f, \"{}\", method)\n    }\n}\n\npub struct MethodError;\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":23},{"path":["/","Users","aw","Dev","Rust","codecrafters-http-server-rust","src","http","mod.rs"],"content":"pub use self::error::{ParseRequestError, ParseRequestErrorKind};\npub use self::method::Method;\npub use self::request::Request;\npub use self::response::Response;\npub use self::response_builder::ResponseBuilder;\npub use self::status_code::StatusCode;\n\nmod error;\nmod method;\nmod request;\nmod response;\nmod response_builder;\nmod status_code;\nmod thread_pool;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aw","Dev","Rust","codecrafters-http-server-rust","src","http","request.rs"],"content":"use std::str::Lines;\n\nuse super::{Method, ParseRequestError, ParseRequestErrorKind};\n\n#[derive(Debug)]\npub struct Request {\n    pub method: Method,\n    pub uri: String,\n    pub headers: Vec<(String, String)>,\n    pub body: Vec<u8>,\n}\n\nimpl TryFrom<&str> for Request {\n    type Error = ParseRequestError;\n\n    fn try_from(request_str: &str) -> Result<Self, Self::Error> {\n        // Get the first line of the request\n        let (first_line, mut rest) = get_next_request_line(request_str)?;\n\n        // Split the first line into the method and the rest of the line\n        let (method, rest_of_line) = get_next_word(first_line).ok_or(ParseRequestError {\n            kind: ParseRequestErrorKind::InvalidRequest,\n        })?;\n\n        // Parse the method\n        let method = method.parse::<Method>()?;\n\n        // Split the rest of the first line into the URI and the protocol\n        let (uri, protocol) = get_next_word(rest_of_line).ok_or(ParseRequestError {\n            kind: ParseRequestErrorKind::InvalidRequest,\n        })?;\n\n        let uri = uri.to_string();\n\n        if !uri.starts_with('/') {\n            return Err(ParseRequestError {\n                kind: ParseRequestErrorKind::InvalidRequest,\n            });\n        }\n\n        // Ensure the protocol is HTTP/1.1\n        if protocol != \"HTTP/1.1\" {\n            // We can get an empty protocol if the method or URI are missing\n            if protocol.is_empty() {\n                return Err(ParseRequestError {\n                    kind: ParseRequestErrorKind::InvalidRequest,\n                });\n            }\n            return Err(ParseRequestError {\n                kind: ParseRequestErrorKind::InvalidProtocol,\n            });\n        }\n\n        let mut headers = Vec::new();\n\n        // Consume iterator lines until we reach an empty line\n        for line in rest.by_ref() {\n            // If the line is empty, we've reached the end of the headers\n            if line.is_empty() {\n                break;\n            }\n\n            // Parse the header\n            let (header_name, header_value) = parse_header(line).ok_or(ParseRequestError {\n                kind: ParseRequestErrorKind::InvalidRequest,\n            })?;\n\n            // Add the header to the headers vector\n            headers.push((header_name.to_string(), header_value.to_string()));\n        }\n\n        // The rest of the request is the body\n        let body: Vec<u8> = rest.flat_map(|line| line.as_bytes().to_owned()).collect();\n\n        Ok(Self {\n            method,\n            uri,\n            headers,\n            body,\n        })\n        // todo!()\n    }\n}\n\nfn get_next_request_line(request_str: &str) -> Result<(&str, Lines), ParseRequestError> {\n    let mut lines = request_str.lines();\n    let first_line = lines.next().ok_or(ParseRequestError {\n        kind: ParseRequestErrorKind::InvalidRequest,\n    });\n\n    Ok((first_line?, lines))\n}\n\nfn get_next_word(request_line: &str) -> Option<(&str, &str)> {\n    if request_line.is_empty() {\n        return None;\n    }\n\n    for (i, c) in request_line.chars().enumerate() {\n        if c == ' ' {\n            return Some((&request_line[..i], &request_line[i + 1..]));\n        }\n    }\n\n    Some((request_line, \"\"))\n}\n\nfn parse_header(header: &str) -> Option<(&str, &str)> {\n    header.split_once(\": \")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_next_word() {\n        assert_eq!(\n            get_next_word(\"GET / HTTP/1.1\"),\n            Some((\"GET\", \"/ HTTP/1.1\")),\n            \"String slice incremental parsing\"\n        );\n        assert_eq!(\n            get_next_word(\"GET /\"),\n            Some((\"GET\", \"/\")),\n            \"String slice incremental parsing\"\n        );\n        assert_eq!(\n            get_next_word(\"GET\"),\n            Some((\"GET\", \"\")),\n            \"String slice incremental parsing\"\n        );\n        assert_eq!(\n            get_next_word(\"\"),\n            None,\n            \"String slice incremental parsing termiantion\"\n        );\n    }\n\n    #[test]\n    fn test_get_next_request_line() {\n        let request = \"GET / HTTP/1.1\\r\\n\";\n        let line = \"GET / HTTP/1.1\";\n        let (req, mut lines) = get_next_request_line(request).unwrap();\n        assert_eq!(req, line, \"First line of the request\");\n        assert!(lines.next().is_none(), \"No more lines\");\n\n        let request = \"GET /\\r\\nHost: localhost:8080\\r\\n\\r\\n\";\n        let line = \"GET /\";\n        let (req, mut lines) = get_next_request_line(request).unwrap();\n        assert_eq!(req, line, \"First line of the request\");\n        assert_eq!(\n            lines.next().unwrap(),\n            \"Host: localhost:8080\",\n            \"Second line of the request\"\n        );\n        assert_eq!(lines.next().unwrap(), \"\", \"Third line of the request\");\n        assert!(lines.next().is_none(), \"No more lines\");\n\n        let request = \"GET\";\n        let line = \"GET\";\n        let (req, mut lines) = get_next_request_line(request).unwrap();\n        assert_eq!(req, line, \"First line of the request\");\n        assert!(lines.next().is_none(), \"No more lines\");\n\n        let request = \"\";\n        let err = get_next_request_line(request).unwrap_err();\n        let err_kind = ParseRequestErrorKind::InvalidRequest;\n        assert_eq!(err.kind, err_kind, \"Empty request\");\n    }\n\n    #[test]\n    fn test_try_from_request() {\n        let request =\n            Request::try_from(\"POST / HTTP/1.1\\r\\nHost: localhost:4221\\r\\nUser-Agent: curl/8.6.0\\r\\nAccept: */*\\r\\nContent-Type: application/json\\r\\nContent-Length: 11\\r\\n\\r\\nHello world\").unwrap();\n        assert_eq!(request.method, Method::Post, \"Method\");\n        assert_eq!(request.uri, \"/\".to_owned(), \"URI\");\n        assert!(request.headers.len() == 5, \"Headers\");\n\n        let header_0 = (\"Host\".to_owned(), \"localhost:4221\".to_owned());\n        let header_1 = (\"User-Agent\".to_owned(), \"curl/8.6.0\".to_owned());\n        let header_2 = (\"Accept\".to_owned(), \"*/*\".to_owned());\n        let header_3 = (\"Content-Type\".to_owned(), \"application/json\".to_owned());\n        let header_4 = (\"Content-Length\".to_owned(), \"11\".to_owned());\n\n        assert_eq!(\n            request.headers[0], header_0,\n            \"Host header with the value localhost:4221\"\n        );\n        assert_eq!(\n            request.headers[1], header_1,\n            \"User-Agent header with the value curl/8.6.0\"\n        );\n        assert_eq!(\n            request.headers[2], header_2,\n            \"Accept header with the value */*\"\n        );\n        assert_eq!(\n            request.headers[3], header_3,\n            \"Content-Type header with the value application/json\"\n        );\n        assert_eq!(\n            request.headers[4], header_4,\n            \"Content-Length header with the value 11\"\n        );\n        assert_eq!(request.body, b\"Hello world\", \"Request body\");\n\n        let request = Request::try_from(\"POST /abc/def HTTP/1.1\\r\\n\\r\\n\").unwrap();\n        assert_eq!(request.method, Method::Post, \"Method\");\n        assert_eq!(request.uri, \"/abc/def\", \"URI\");\n        assert!(request.headers.is_empty(), \"Headers are empty\");\n        assert!(request.body.is_empty(), \"Request body is empty\");\n\n        let request = Request::try_from(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n        let err_kind = ParseRequestErrorKind::InvalidProtocol;\n        assert_eq!(\n            request.unwrap_err().kind,\n            err_kind,\n            \"Invalid protocol error\"\n        );\n\n        let request = Request::try_from(\"GET abc HTTP/1.0\\r\\n\\r\\n\");\n        let err_kind = ParseRequestErrorKind::InvalidRequest;\n        assert_eq!(request.unwrap_err().kind, err_kind, \"Invalid request error\");\n\n        let request = Request::try_from(\"GETT / HTTP/1.1\\r\\n\\r\\n\");\n        let err_kind = ParseRequestErrorKind::InvalidMethod;\n        assert_eq!(request.unwrap_err().kind, err_kind, \"Invalid method error\");\n\n        let request = Request::try_from(\"GET HTTP/1.1\\r\\n\\r\\n\");\n        let err_kind = ParseRequestErrorKind::InvalidRequest;\n        assert_eq!(request.unwrap_err().kind, err_kind, \"Invalid request error\");\n    }\n\n    #[test]\n    fn test_parse_header() {\n        let arg = \"Host: localhost:4221\";\n        let expected = Some((\"Host\", \"localhost:4221\"));\n        assert_eq!(parse_header(arg), expected, \"Host header\");\n\n        let arg = \"User-Agent: curl/8.6.0\";\n        let expected = Some((\"User-Agent\", \"curl/8.6.0\"));\n        assert_eq!(parse_header(arg), expected, \"User-Agent header\");\n\n        let arg = \"Accept: */*\";\n        let expected = Some((\"Accept\", \"*/*\"));\n        assert_eq!(parse_header(arg), expected, \"Accept header\");\n\n        let arg = \"Content-Type: application/json\";\n        let expected = Some((\"Content-Type\", \"application/json\"));\n        assert_eq!(parse_header(arg), expected, \"Content-Type header\");\n\n        let arg = \"Content-Length: 11\";\n        let expected = Some((\"Content-Length\", \"11\"));\n        assert_eq!(parse_header(arg), expected, \"Content-Length header\");\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":130},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":130},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":11},"fn_name":null}],"covered":31,"coverable":33},{"path":["/","Users","aw","Dev","Rust","codecrafters-http-server-rust","src","http","response.rs"],"content":"use std::fmt::{Display, Write};\n\nuse super::status_code::StatusCode;\n\n#[derive(Debug, PartialEq, Eq, Clone, Default)]\npub struct Response {\n    pub status_code: StatusCode,\n    pub headers: Vec<(String, String)>,\n    pub body: Option<Vec<u8>>,\n}\n\nimpl Response {\n    pub fn to_bytes_vec(&self) -> Vec<u8> {\n        let mut response: Vec<u8> = Vec::new();\n\n        let status_code: String = format!(\"{}\", self.status_code);\n\n        let mut headers: Vec<u8> = self.headers.iter().fold(vec![], |mut acc, (k, v)| {\n            acc.extend_from_slice(k.as_bytes());\n            acc.extend_from_slice(b\": \");\n            acc.extend_from_slice(v.as_bytes());\n            acc.extend_from_slice(b\"\\r\\n\");\n            acc\n        });\n\n        // Add additional CLRF after all headers\n        headers.extend_from_slice(b\"\\r\\n\");\n\n        if let Some(body) = &self.body {\n            response.extend_from_slice(status_code.as_bytes());\n            response.extend(headers);\n            response.extend_from_slice(body);\n        } else {\n            response.extend_from_slice(status_code.as_bytes());\n            response.extend(headers);\n        }\n\n        response\n    }\n}\n\nimpl Display for Response {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        let headers = self.headers.iter().fold(String::new(), |mut acc, (k, v)| {\n            let _ = write!(acc, \"{}: {}\\r\\n\", k, v);\n            acc\n        });\n\n        if let Some(body) = &self.body {\n            write!(\n                f,\n                \"{}{}\\r\\n{}\",\n                self.status_code,\n                headers,\n                String::from_utf8_lossy(body)\n            )\n        } else {\n            write!(f, \"{}{}\\r\\n\", self.status_code, headers)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::http::ResponseBuilder;\n\n    #[test]\n    fn test_response_to_bytes_vec() {\n        let response = ResponseBuilder::ok()\n            .with((\"Content-Type\", \"text/plain\"))\n            .body(\"Hello, World!\")\n            .build();\n        let expected = b\"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\".to_vec();\n\n        assert_eq!(\n            response.to_bytes_vec(),\n            expected,\n            \"Response should be converted to bytes vector\"\n        );\n    }\n\n    #[test]\n    fn test_response_to_string() {\n        let response = ResponseBuilder::ok()\n            .with((\"Content-Type\", \"text/plain\"))\n            .body(\"Hello, World!\")\n            .build();\n        let expected = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\";\n\n        assert_eq!(\n            response.to_string(),\n            expected,\n            \"Response should be converted to string\"\n        );\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":18,"coverable":20},{"path":["/","Users","aw","Dev","Rust","codecrafters-http-server-rust","src","http","response_builder.rs"],"content":"use super::{Response, StatusCode};\nuse std::default::Default;\n\n#[derive(Clone, Debug)]\npub struct ResponseBuilder<S> {\n    status_code: S,\n    headers: Option<Vec<(String, String)>>,\n    body: Option<Vec<u8>>,\n    set_content_length_header: bool,\n}\n\nimpl ResponseBuilder<MissingStatusCode> {\n    pub fn ok() -> ResponseBuilder<StatusCode> {\n        ResponseBuilder {\n            status_code: StatusCode::Ok,\n            ..Default::default()\n        }\n    }\n\n    pub fn not_found() -> ResponseBuilder<StatusCode> {\n        ResponseBuilder {\n            status_code: StatusCode::NotFound,\n            ..Default::default()\n        }\n    }\n\n    pub fn bad_request() -> ResponseBuilder<StatusCode> {\n        ResponseBuilder {\n            status_code: StatusCode::BadRequest,\n            ..Default::default()\n        }\n    }\n\n    pub fn internal_server_error() -> ResponseBuilder<StatusCode> {\n        ResponseBuilder {\n            status_code: StatusCode::InternalServerError,\n            ..Default::default()\n        }\n    }\n}\n\nimpl ResponseBuilder<StatusCode> {\n    pub fn build(self) -> Response {\n        // Calculate the Content-Length header value\n        let content_length = self.body.as_ref().map(|b| b.len()).unwrap_or(0);\n        let mut headers = self.headers.unwrap_or_default();\n\n        // Set the Content-Length header if the `without_content_length_header` method was not called\n        match self.set_content_length_header {\n            false => (), // No Content-Length header for empty bodies\n            true => headers.push((\"Content-Length\".to_string(), content_length.to_string())),\n        }\n\n        Response {\n            status_code: self.status_code,\n            headers,\n            body: self.body,\n        }\n    }\n}\n\nimpl<S> ResponseBuilder<S> {\n    /// # Set header(s) on the response.\n    ///\n    /// You can set a single header multiple times, or multiple headers at once.\n    ///\n    /// When you set a single header, pass a tuple `(header_key, header_value)` with\n    /// values implementing the `Into<String>` trait.\n    ///\n    /// When you set multiple headers, pass a vector of tuples `Vec<(header_key, header_value)>`\n    /// with values implementing the `Into<String>` trait.\n    ///\n    /// Do not set the `Content-Length` header manually. It is calculated automatically based on\n    /// the body length.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::ResponseBuilder;\n    /// let response = ResponseBuilder::ok()\n    ///     .with((\"Content-Type\", \"text/plain\"))\n    ///     .with(vec![(\"X-Custom-Header\", \"value\"), (\"Keep-Alive\", \"timeout=5, max=1000\")])\n    ///     .build();\n    ///\n    /// let expected_headers = vec![\n    ///     (\"Content-Type\".to_string(), \"text/plain\".to_string()),\n    ///     (\"X-Custom-Header\".to_string(), \"value\".to_string()),\n    ///     (\"Keep-Alive\".to_string(), \"timeout=5, max=1000\".to_string()),\n    ///     (\"Content-Length\".to_string(), \"0\".to_string()),\n    /// ];\n    ///\n    /// let response_string = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nX-Custom-Header: value\\r\\nKeep-Alive: timeout=5, max=1000\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n    ///\n    /// assert_eq!(response.headers.len(), expected_headers.len());\n    /// assert_eq!(response.headers, expected_headers);\n    /// assert_eq!(response.to_string(), response_string);\n    /// ```\n    pub fn with<T: Into<String>>(self, part: impl IntoResponsePart<T>) -> Self {\n        match part.into_response_part() {\n            ResponsePart::Header(key, value) => self.header(key, value),\n            ResponsePart::Headers(headers) => self.headers(headers),\n        }\n    }\n\n    fn header(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {\n        let key: String = key.into();\n\n        if key.as_str() != \"Content-Length\" {\n            if let Some(ref mut headers) = self.headers {\n                headers.push((key, value.into()));\n            } else {\n                self.headers = Some(vec![(key, value.into())]);\n            }\n        }\n\n        self\n    }\n\n    fn headers(mut self, headers: Vec<(impl Into<String>, impl Into<String>)>) -> Self {\n        // Filter out the Content-Length header and convert headers' keys and values to owned strings\n        let headers = headers\n            .into_iter()\n            .map(|(key, value)| -> (String, String) { (key.into(), value.into()) })\n            .filter(|(key, _)| key.clone().as_str() != \"Content-Length\")\n            .collect::<Vec<_>>();\n\n        if let Some(ref mut existing_headers) = self.headers {\n            existing_headers.extend(headers); // Extend existing headers\n        } else {\n            self.headers = Some(headers); // Set the headers\n        }\n\n        self\n    }\n\n    // This method is used to not to set the Content-Length header on empty bodies to pass codecrafters tests\n    /// # Do not set the Content-Length header on the response.\n    ///\n    /// This method is used to not to set the Content-Length header.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::ResponseBuilder;\n    /// let response = ResponseBuilder::ok()\n    ///     .without_content_length_header()\n    ///     .build();\n    ///\n    /// assert_eq!(response.headers.len(), 0);\n    /// ```\n    pub fn without_content_length_header(mut self) -> Self {\n        self.set_content_length_header = false;\n        self\n    }\n\n    /// # Set the body of the response.\n    ///\n    /// The body is a byte vector. To set the body, pass any value implementing the\n    /// `Into<Vec<u8>>` trait.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::ResponseBuilder;\n    /// let response = ResponseBuilder::ok()\n    ///     .body(\"Hello, world!\")\n    ///     .build();\n    ///\n    /// assert_eq!(response.body, Some(\"Hello, world!\".as_bytes().to_vec()));\n    /// ```\n    pub fn body(mut self, body: impl Into<Vec<u8>>) -> Self {\n        self.body = Some(body.into());\n        self\n    }\n}\n\nimpl Default for ResponseBuilder<StatusCode> {\n    fn default() -> Self {\n        ResponseBuilder {\n            status_code: StatusCode::Ok,\n            headers: None,\n            body: None,\n            set_content_length_header: true,\n        }\n    }\n}\n\n// Auxiliary type to represent a missing status code in the builder\n#[derive(Clone, Default)]\npub struct MissingStatusCode;\n\n// Auxiliary enum to represent a part of a response\npub enum ResponsePart<T> {\n    Header(T, T),\n    Headers(Vec<(T, T)>),\n}\n\n// Trait to convert header value(s) into a response part\npub trait IntoResponsePart<T> {\n    fn into_response_part(self) -> ResponsePart<T>;\n}\n\n// Implement the IntoResponsePart trait for tuples of two elements to represent a single header\nimpl<T: Into<String>> IntoResponsePart<T> for (T, T) {\n    fn into_response_part(self) -> ResponsePart<T> {\n        ResponsePart::Header(self.0, self.1)\n    }\n}\n\n// Implement the IntoResponsePart trait for vectors of tuples of two elements to represent multiple headers\nimpl<T: Into<String>> IntoResponsePart<T> for Vec<(T, T)> {\n    fn into_response_part(self) -> ResponsePart<T> {\n        ResponsePart::Headers(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_response_builder_default() {\n        let response = ResponseBuilder::default().build();\n\n        assert_eq!(\n            response.status_code,\n            StatusCode::Ok,\n            \"Status code should be 200 OK\"\n        );\n        assert_eq!(\n            response.headers,\n            vec![(\"Content-Length\".to_string(), \"0\".to_string())],\n            \"Headers should contain Content-Length: 0\"\n        );\n        assert!(response.body.is_none(), \"No body should be set\");\n        assert_eq!(\n            response.to_string(),\n            \"HTTP/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\",\n            \"Response string should be 200 OK\"\n        );\n    }\n\n    #[test]\n    fn test_response_builder_ok() {\n        let response = ResponseBuilder::ok().build();\n        assert_eq!(\n            response.status_code,\n            StatusCode::Ok,\n            \"Status code should be 200 OK\"\n        );\n    }\n\n    #[test]\n    fn test_response_builder_not_found() {\n        let response = ResponseBuilder::not_found().build();\n        assert_eq!(\n            response.status_code,\n            StatusCode::NotFound,\n            \"Status code should be 404 Not Found\"\n        );\n    }\n\n    #[test]\n    fn test_response_builder_bad_request() {\n        let response = ResponseBuilder::bad_request().build();\n        assert_eq!(\n            response.status_code,\n            StatusCode::BadRequest,\n            \"Status code should be 400 Bad Request\"\n        );\n    }\n\n    #[test]\n    fn test_response_builder_internal_server_error() {\n        let response = ResponseBuilder::internal_server_error().build();\n        assert_eq!(\n            response.status_code,\n            StatusCode::InternalServerError,\n            \"Status code should be 500 Internal Server Error\"\n        );\n    }\n\n    #[test]\n    fn test_without_content_length_header() {\n        let response = ResponseBuilder::ok()\n            .without_content_length_header()\n            .build();\n\n        dbg!(&response.headers);\n        assert_eq!(\n            response.headers,\n            vec![],\n            \"No headers should be set when the `without_content_length_header` method is called\"\n        );\n\n        let response = ResponseBuilder::ok().build();\n\n        assert_eq!(\n            response.headers,\n            vec![(\"Content-Length\".to_string(), \"0\".to_string())],\n            \"Headers should contain Content-Length: 0\"\n        );\n\n        // Manually set Content-Length header and then call without_content_length_header\n        let response = ResponseBuilder::ok()\n            .with((\"Content-Length\", \"0\"))\n            .without_content_length_header()\n            .build();\n\n        assert_eq!(response.headers.len(), 0, \"No headers should be set\");\n        assert_eq!(response.headers, vec![], \"No headers should be set\");\n    }\n\n    #[test]\n    fn test_response_builder_with() {\n        // Set a single header\n        let response = ResponseBuilder::ok()\n            .with((\"Content-Type\", \"text/html\"))\n            .without_content_length_header()\n            .build();\n\n        let headers = vec![(\"Content-Type\".to_string(), \"text/html\".to_string())];\n\n        assert_eq!(response.headers.len(), 1, \"One header should be set\");\n        assert_eq!(\n            response.headers, headers,\n            \"Headers should contain Content-Type: text/html only\"\n        );\n\n        // Set multiple headers at once\n        let response = ResponseBuilder::ok()\n            .with(vec![(\"Content-Type\", \"text/html\"), (\"X-Custom\", \"value\")])\n            .build();\n\n        let headers = vec![\n            (\"Content-Type\".to_string(), \"text/html\".to_string()),\n            (\"X-Custom\".to_string(), \"value\".to_string()),\n            (\"Content-Length\".to_string(), \"0\".to_string()),\n        ];\n\n        assert_eq!(response.headers.len(), 3, \"Three headers should be set\");\n        assert_eq!(\n            response.headers, headers,\n            \"Headers should contain Content-Type: text/html, X-Custom: value, and Content-Length: 4\"\n        );\n    }\n\n    #[test]\n    fn test_response_builder_body() {\n        let body = \"Hello, world!\";\n        let response = ResponseBuilder::ok().body(body).build();\n        assert_eq!(\n            response.body.unwrap(),\n            body.as_bytes().to_vec(),\n            \"Body should be set to the given value\"\n        );\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":40,"coverable":41},{"path":["/","Users","aw","Dev","Rust","codecrafters-http-server-rust","src","http","status_code.rs"],"content":"use std::fmt::{Display, Result as FmtResult};\n\n#[derive(Debug, PartialEq, Clone, Copy, Eq, Default)]\npub enum StatusCode {\n    #[default]\n    Ok = 200,\n    BadRequest = 400,\n    NotFound = 404,\n    InternalServerError = 500,\n}\n\nimpl StatusCode {\n    pub fn message(&self) -> &'static str {\n        match self {\n            StatusCode::Ok => \"OK\",\n            StatusCode::BadRequest => \"Bad Request\",\n            StatusCode::NotFound => \"Not Found\",\n            StatusCode::InternalServerError => \"Internal Server Error\",\n        }\n    }\n}\n\nimpl Display for StatusCode {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> FmtResult {\n        write!(f, \"HTTP/1.1 {} {}\\r\\n\", *self as u16, self.message())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn status_code_message() {\n        assert_eq!(\n            StatusCode::Ok.message(),\n            \"OK\",\n            \"Status code 200 should be OK\"\n        );\n        assert_eq!(\n            StatusCode::BadRequest.message(),\n            \"Bad Request\",\n            \"Status code 400 should be Bad Request\"\n        );\n        assert_eq!(\n            StatusCode::NotFound.message(),\n            \"Not Found\",\n            \"Status code 404 should be Not Found\"\n        );\n        assert_eq!(\n            StatusCode::InternalServerError.message(),\n            \"Internal Server Error\",\n            \"Status code 500 should be Internal Server Error\"\n        );\n    }\n\n    #[test]\n    fn status_code_display() {\n        assert_eq!(\n            format!(\"{}\", StatusCode::Ok),\n            \"HTTP/1.1 200 OK\\r\\n\",\n            \"Status code string 200 should be OK\"\n        );\n        assert_eq!(\n            format!(\"{}\", StatusCode::BadRequest),\n            \"HTTP/1.1 400 Bad Request\\r\\n\",\n            \"Status code string 400 should be Bad Request\"\n        );\n        assert_eq!(\n            format!(\"{}\", StatusCode::NotFound),\n            \"HTTP/1.1 404 Not Found\\r\\n\",\n            \"Status code string 404 should be Not Found\"\n        );\n        assert_eq!(\n            format!(\"{}\", StatusCode::InternalServerError),\n            \"HTTP/1.1 500 Internal Server Error\\r\\n\",\n            \"Status code string 500 should be Internal Server Error\"\n        );\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","Users","aw","Dev","Rust","codecrafters-http-server-rust","src","http","thread_pool.rs"],"content":"use std::{\n    sync::{mpsc, Arc, Mutex},\n    thread::JoinHandle,\n};\n\n#[derive(Debug)]\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Job>,\n}\n\n#[derive(Debug)]\nstruct Worker {\n    id: usize,\n    thread: JoinHandle<()>,\n}\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool with the specified number of threads.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> Self {\n        assert!(size > 0, \"ThreadPool size must be greater than 0\");\n\n        let mut workers = Vec::with_capacity(size);\n\n        let (tx, rx) = mpsc::channel::<Job>();\n\n        // Wrap the receiver in an Arc and a Mutex so we can share it among the workers\n        let receiver = Arc::new(Mutex::new(rx));\n\n        for id in 0..size {\n            let worker = Worker::new(id, receiver.clone());\n            workers.push(worker);\n        }\n\n        Self {\n            workers,\n            sender: tx,\n        }\n    }\n\n    pub fn execute<F: FnOnce() + Send + 'static>(&self, f: F) {\n        let job = Box::new(f);\n        self.sender\n            .send(job)\n            .expect(\"Worker we are sending to has died!\");\n    }\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = std::thread::Builder::new()\n            .spawn(move || loop {\n                let job = receiver\n                    .lock()\n                    .expect(\"Mutex is in a poisoning state!\")\n                    .recv()\n                    .expect(\"Sender was dropped!\");\n\n                println!(\"Worker {id} got a job; executing...\");\n\n                job();\n            })\n            .unwrap();\n\n        Worker { id, thread }\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","Users","aw","Dev","Rust","codecrafters-http-server-rust","src","main.rs"],"content":"#![allow(dead_code)]\nuse std::env;\nuse tokio::net::TcpListener;\n\nuse self::handlers::handle_connection;\n\nmod handlers;\nmod http;\n\n#[tokio::main(flavor = \"multi_thread\", worker_threads = 4)]\nasync fn main() {\n    let args: Vec<String> = env::args().collect();\n    let directory = args\n        .iter()\n        .position(|arg| arg == \"--directory\")\n        .and_then(|pos| args.get(pos + 1).cloned());\n\n    let files_dir = directory.unwrap_or_else(|| \"\".to_string());\n\n    let listener = TcpListener::bind(\"127.0.0.1:4221\").await.unwrap();\n\n    loop {\n        let (stream, _) = listener.accept().await.unwrap();\n        let files_dir = files_dir.clone();\n        tokio::task::spawn(async move {\n            handle_connection(stream, &files_dir).await.unwrap();\n        });\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12}],"coverage":60.66350710900474,"covered":128,"coverable":211}